/**
 * Copyright 2018, FleetTLC. All rights reserved
 */
package com.cartlc.tracker.ui.app

import android.Manifest
import android.app.Activity
import android.app.Application
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import androidx.core.content.FileProvider
import android.view.View
import android.view.inputmethod.InputMethodManager
import androidx.multidex.MultiDex

import com.cartlc.tracker.BuildConfig
import com.cartlc.tracker.R
import com.cartlc.tracker.model.CarRepository
import com.cartlc.tracker.ui.util.CheckError
import com.cartlc.tracker.model.pref.PrefHelper
import com.cartlc.tracker.model.event.EventError
import com.cartlc.tracker.model.server.AmazonHelper
import com.cartlc.tracker.model.server.DCService
import com.cartlc.tracker.model.server.ServerHelper
import com.cartlc.tracker.model.table.DatabaseTable
import com.cartlc.tracker.ui.util.LocationHelper
import com.cartlc.tracker.ui.util.PermissionHelper.PermissionRequest
import com.cartlc.tracker.ui.util.PermissionHelper.PermissionListener

import de.greenrobot.event.EventBus
import timber.log.Timber

import com.cartlc.tracker.ui.util.PermissionHelper
import com.cartlc.tracker.viewmodel.MainViewModel
import com.cartlc.tracker.viewmodel.MainViewModelComponent
import com.cartlc.tracker.viewmodel.MainViewModelModule
import com.squareup.leakcanary.LeakCanary

import com.cartlc.tracker.viewmodel.DaggerMainViewModelComponent

import java.io.File
import javax.inject.Inject

class TBApplication : Application() {

    companion object {

        internal val OVERRIDE_IS_DEVELOPMENT_SERVER: Boolean? = null

        fun IsDevelopmentServer(): Boolean {
            return OVERRIDE_IS_DEVELOPMENT_SERVER ?: BuildConfig.DEBUG
        }

        internal val DEBUG_TREE = false
        internal val LEAK_CANARY = false

        val REPORT_LOCATION = true // BuildConfig.DEBUG;

        val OTHER = "Other"

        internal val PERMISSIONS = arrayOf(PermissionRequest(Manifest.permission.WRITE_EXTERNAL_STORAGE, R.string.perm_read_external_storage), PermissionRequest(Manifest.permission.READ_EXTERNAL_STORAGE, R.string.perm_write_external_storage), PermissionRequest(Manifest.permission.ACCESS_FINE_LOCATION, R.string.perm_location))

        fun getUri(ctx: Context, file: File): Uri {
            return FileProvider.getUriForFile(ctx, "com.cartcl.tracker.fileprovider", file)
        }

        fun hideKeyboard(ctx: Context, v: View) {
            val imm = ctx.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
            imm.hideSoftInputFromWindow(v.windowToken, 0)
        }

        fun ReportError(ex: Exception, claz: Class<*>, function: String, type: String): String {
            return ReportError(ex.message
                    ?: "unknown", claz, function, type)
        }

        fun ReportError(msg: String, claz: Class<*>, function: String, type: String): String {
            val sbuf = StringBuilder()
            sbuf.append("Class:")
            sbuf.append(claz.simpleName)
            sbuf.append(".")
            sbuf.append(function)
            sbuf.append(" ")
            sbuf.append(type)
            sbuf.append(": ")
            sbuf.append(msg)
            Timber.e(sbuf.toString())
            return sbuf.toString()
        }

        fun ReportServerError(ex: Exception, claz: Class<*>, function: String, type: String) {
            val msg = ReportError(ex, claz, function, type)
            ShowError(msg)
        }

        fun ShowError(msg: String) {
            EventBus.getDefault().post(EventError(msg))
        }
    }

    lateinit var appComponent: MainViewModelComponent
    @Inject
    lateinit var vm: MainViewModel

    val prefHelper: PrefHelper
        get() = vm.prefHelper
    val db: DatabaseTable
        get() = vm.db

    val version: String
        @Throws(PackageManager.NameNotFoundException::class)
        get() {
            val sbuf = StringBuilder()
            val version = packageManager.getPackageInfo(packageName, 0).versionName
            sbuf.append("v")
            sbuf.append(version)
            if (prefHelper.isDevelopment) {
                sbuf.append("d")
            }
            return sbuf.toString()
        }

    override fun onCreate() {
        super.onCreate()

        appComponent = DaggerMainViewModelComponent.builder()
                .mainViewModelModule(MainViewModelModule(CarRepository(this)))
                .build()
        appComponent.inject(this)

        if (LEAK_CANARY) {
            if (LeakCanary.isInAnalyzerProcess(this)) {
                // This process is dedicated to LeakCanary for heap analysis.
                // You should not init your app in this process.
                return
            }
            LeakCanary.install(this)
        }
        if (IsDevelopmentServer() && DEBUG_TREE) {
            Timber.plant(Timber.DebugTree())
        } else {
            Timber.plant(CrashReportingTree(db))
        }
        ServerHelper.Init(this)
        AmazonHelper.Init(db, prefHelper)
        PermissionHelper.Init()
        CheckError.Init()

        prefHelper.detectSpecialUpdateCheck()
        LocationHelper.Init(this)
    }

    fun ping() {
        if (ServerHelper.instance.hasConnection(this)) {
            startService(Intent(this, DCService::class.java))
        }
    }

    fun requestZipCode(zipCode: String) {
        val data = db.zipCode.query(zipCode)
        if (data != null) {
            data.check()
            EventBus.getDefault().post(data)
        } else if (ServerHelper.instance.hasConnection(this)) {
            val intent = Intent(this, DCService::class.java)
            intent.action = DCService.ACTION_ZIP_CODE
            intent.putExtra(DCService.DATA_ZIP_CODE, zipCode)
            startService(intent)
        }
    }

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base)
        MultiDex.install(this)
    }

    @Suppress("UNUSED_PARAMETER")
    fun setUncaughtExceptionHandler(act: Activity) {
        //        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
        //            @Override
        //            public void uncaughtException(Thread t, Throwable e) {
        //                crashTree.log(Log.ERROR, "CarTLCarTLC", e.getMessage(), null);
        //                act.finish();
        //            }
        //        });
    }

    fun checkPermissions(act: Activity, listener: PermissionListener) {
        PermissionHelper.instance.checkPermissions(act, PERMISSIONS, listener)
    }

}
